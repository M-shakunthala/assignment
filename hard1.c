[{"insert":"Hard 1\nGiven an m x n binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area.\nExample:1\nInput: matrix = [[\"0\"]]\nOutput: 0\nExample 2:\nInput: matrix = [[\"0\",\"1\"],[\"1\",\"0\"]]\nOutput: 1\nExample:3\nInput: matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]]\nOutput: 4\nCODE\n\n#include <stdio.h>\n#include <stdlib.h>\n\nstruct Deque {\n    int capacity;\n    int size;\n    int front;\n    int rear;\n    int* array;\n};\n\nstruct Deque* createDeque(int capacity) {\n    struct Deque* deque = (struct Deque*)malloc(sizeof(struct Deque));\n    deque->capacity = capacity;\n    deque->size = 0;\n    deque->front = -1;\n    deque->rear = -1;\n    deque->array = (int*)malloc(capacity * sizeof(int));\n    return deque;\n}\n\nint isEmpty(struct Deque* deque) {\n    return deque->size == 0;\n}\n\nint isFull(struct Deque* deque) {\n    return deque->size == deque->capacity;\n}\n\nvoid pushBack(struct Deque* deque, int value) {\n    if (isFull(deque)) {\n        return;\n    }\n    if (isEmpty(deque)) {\n        deque->front = 0;\n    }\n    deque->rear = (deque->rear + 1) % deque->capacity;\n    deque->array[deque->rear] = value;\n    deque->size++;\n}\n\nvoid popFront(struct Deque* deque) {\n    if (isEmpty(deque)) {\n        return;\n    }\n    if (deque->front == deque->rear) {\n        deque->front = -1;\n        deque->rear = -1;\n    } else {\n        deque->front = (deque->front + 1) % deque->capacity;\n    }\n    deque->size--;\n}\n\nint front(struct Deque* deque) {\n    if (isEmpty(deque)) {\n        return -1;\n    }\n    return deque->array[deque->front];\n}\n\nint* maxSlidingWindow(int* nums, int numsSize, int k, int* returnSize) {\n    if (numsSize == 0) {\n        *returnSize = 0;\n        return NULL;\n    }\n\n    *returnSize = numsSize - k + 1;\n    int* result = (int*)malloc((*returnSize) * sizeof(int));\n    struct Deque* deque = createDeque(k);\n\n    for (int i = 0; i < k; i++) {\n        while (!isEmpty(deque) && nums[i] >= nums[front(deque)]) {\n            popFront(deque);\n        }\n        pushBack(deque, i);\n    }\n\n    int resultIndex = 0;\n    for (int i = k; i < numsSize; i++) {\n        result[resultIndex++] = nums[front(deque)];\n\n        while (!isEmpty(deque) && front(deque) <= i - k) {\n            popFront(deque);\n        }\n\n        while (!isEmpty(deque) && nums[i] >= nums[front(deque)]) {\n            popFront(deque);\n        }\n\n        pushBack(deque, i);\n    }\n\n    result[resultIndex] = nums[front(deque)];\n\n    free(deque->array);\n    free(deque);\n\n    return result;\n}\n\nint main() {\n    int nums1[] = {1};\n    int k1 = 1;\n    int size1;\n    int* result1 = maxSlidingWindow(nums1, 1, k1, &size1);\n\n    printf(\"Output 1: [\");\n    for (int i = 0; i < size1; i++) {\n        printf(\"%d \", result1[i]);\n    }\n    printf(\"]\\n\");\n\n    free(result1);\n\n    return 0;\n}\nOUTPUT\nOutput : [1 ]\n"}]