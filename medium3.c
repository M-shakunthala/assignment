[{"insert":"Medium 3\nGiven an m x n binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area.\nExample 1:\nInput: matrix = [[\"0\"]]\nOutput: 0\nExample 2:\nInput: matrix = [[\"0\",\"1\"],[\"1\",\"0\"]]\nOutput: 1\nExample 3:\nInput: matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]]\nOutput: 4\n\nCODE\n\n#include <stdio.h>\n#include <stdlib.h>\n\nint min(int a, int b, int c) {\n    int min_val = a;\n    if (b < min_val) {\n        min_val = b;\n    }\n    if (c < min_val) {\n        min_val = c;\n    }\n    return min_val;\n}\n\nint maximalSquare(char** matrix, int matrixSize, int* matrixColSize) {\n    if (matrixSize == 0 || *matrixColSize == 0) {\n        return 0;\n    }\n\n    int rows = matrixSize;\n    int cols = *matrixColSize;\n    int maxSide = 0;\n\n    int** dp = (int*)malloc(sizeof(int) * (rows + 1));\n    for (int i = 0; i <= rows; ++i) {\n        dp[i] = (int*)malloc(sizeof(int) * (cols + 1));\n    }\n\n    for (int i = 0; i <= rows; ++i) {\n        dp[i][0] = 0;\n    }\n    for (int j = 0; j <= cols; ++j) {\n        dp[0][j] = 0;\n    }\n\n    for (int i = 1; i <= rows; ++i) {\n        for (int j = 1; j <= cols; ++j) {\n            if (matrix[i - 1][j - 1] == '1') {\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1;\n                if (dp[i][j] > maxSide) {\n                    maxSide = dp[i][j];\n                }\n            } else {\n                dp[i][j] = 0;\n            }\n        }\n    }\n\n    int maxArea = maxSide * maxSide;\n\n    for (int i = 0; i <= rows; ++i) {\n        free(dp[i]);\n    }\n    free(dp);\n\n    return maxArea;\n}\n\nint main() {\n    char* matrix1[] = {\"0\"};\n    int colSize1[] = {1};\n    int result1 = maximalSquare(matrix1, 1, colSize1);\n    printf(\"Output for matrix 1: %d\\n\", result1);\n\n    \n\n    return 0;\n}\nOUTPUT\nOutput for matrix 1: 0\n"}]