[{"insert":"Easy 2\nGiven an integer array nums where the elements are sorted in ascending order, convert it to a \nheight-balanced binary search tree.\n \nExample 1:\n\nInput: nums = [-10,-3,0,5,9]\nOutput: [0,-3,9,-10,null,5]\nExplanation: [0,-10,5,null,-3,null,9] is also accepted:\n\nExample 2:\n\nInput: nums = [1,3]\nOutput: [3,1]\nExplanation: [1,null,3] and [3,1] are both height-balanced BSTs.\n\nCODE\n\n#include <stdio.h>\n#include <stdlib.h>\n\nstruct TreeNode {\n    int val;\n    struct TreeNode *left;\n    struct TreeNode *right;\n};\n\nstruct TreeNode* newNode(int val) {\n    struct TreeNode* node = (struct TreeNode*)malloc(sizeof(struct TreeNode));\n    node->val = val;\n    node->left = node->right = NULL;\n    return node;\n}\n\nstruct TreeNode* sortedArrayToBST(int* nums, int left, int right) {\n    if (left > right) {\n        return NULL;\n    }\n\n    int mid = left + (right - left) / 2;\n    struct TreeNode* root = newNode(nums[mid]);\n\n    root->left = sortedArrayToBST(nums, left, mid - 1);\n    root->right = sortedArrayToBST(nums, mid + 1, right);\n\n    return root;\n}\n\nvoid printTree(struct TreeNode* root) {\n    if (root != NULL) {\n        printf(\"%d\", root->val);\n        \n        if (root->left != NULL || root->right != NULL) {\n            printf(\", \");\n            printTree(root->left);\n            if (root->right != NULL) {\n                printf(\", \");\n                printTree(root->right);\n            }\n        }\n    } else {\n        printf(\"null\");\n    }\n}\n\nint main() {\n    int nums[] = {-10, -3, 0, 5, 9};\n    int size = sizeof(nums) / sizeof(nums[0]);\n\n    struct TreeNode* root = sortedArrayToBST(nums, 0, size - 1);\n\n    printf(\"Output: [\");\n    printTree(root);\n    printf(\"]\\n\");\n\n    return 0;\n}\nOUTPUT\nOutput: [0, -10, null, -3, 5, null, 9]\n"}]